import { EditFileParams } from './edit-file';
import { ApplyDiffParams } from './apply-diff';

/**
 * Tool definition interface
 */
export interface ToolDefinition {
  name: string;
  description: string;
  inputSchema: {
    type: string;
    properties: Record<string, any>;
    required: string[];
  };
}

/**
 * Tool definition for edit_file
 * 
 * This tool provides atomic file editing using search/replace operations.
 * All edits are validated before any changes are made, ensuring atomicity.
 */
export const EDIT_FILE_TOOL: ToolDefinition = {
  name: 'edit_file',
  description: `Edit a file using search/replace operations with atomic guarantees.

Key features:
- Atomicity: All edits succeed or all fail (file remains unchanged)
- Exact matching: Search patterns must match exactly once
- Clear errors: Detailed messages with context when patterns don't match
- Multiple edits: Apply multiple changes in a single atomic operation
- Dry-run mode: Preview changes before applying them

Use this tool when:
- Making multiple related changes to a file
- Need to ensure all changes succeed together
- Want to avoid line-number fragility (changes elsewhere don't break your edits)

Limitations:
- Search patterns must be unique in the file
- Patterns are case-sensitive and whitespace-sensitive
- Edit operations cannot overlap`,
  inputSchema: {
    type: 'object',
    properties: {
      path: {
        type: 'string',
        description: 'Absolute or relative path to the file to edit'
      },
      edits: {
        type: 'array',
        description: 'Array of edit operations to apply atomically',
        items: {
          type: 'object',
          properties: {
            search: {
              type: 'string',
              description: 'Exact text to find in the file (must appear exactly once)'
            },
            replace: {
              type: 'string',
              description: 'Text to replace the found text with'
            },
            description: {
              type: 'string',
              description: 'Optional human-readable description of this change'
            }
          },
          required: ['search', 'replace']
        }
      },
      dryRun: {
        type: 'boolean',
        description: 'If true, validate and preview changes without modifying the file',
        default: false
      }
    },
    required: ['path', 'edits']
  }
};

/**
 * Tool definition for apply_diff
 * 
 * This tool applies unified diff patches to files.
 * Useful for applying changes generated by version control systems.
 */
export const APPLY_DIFF_TOOL: ToolDefinition = {
  name: 'apply_diff',
  description: `Apply a unified diff patch to a file.

This tool accepts diffs in the unified diff format (like those produced by git diff or diff -u).
It can apply multiple hunks in a single operation.

Use this tool when:
- Applying patches from version control
- Working with diff output from other tools
- Need to apply changes that span multiple non-contiguous sections

Limitations:
- Requires valid unified diff format
- Line numbers must match current file state
- Cannot handle merge conflicts`,
  inputSchema: {
    type: 'object',
    properties: {
      path: {
        type: 'string',
        description: 'Absolute or relative path to the file to patch'
      },
      diff: {
        type: 'string',
        description: 'Unified diff format string to apply (including @@ hunk headers)'
      },
      dryRun: {
        type: 'boolean',
        description: 'If true, preview changes without modifying the file',
        default: false
      }
    },
    required: ['path', 'diff']
  }
};

/**
 * All available tool definitions
 */
export const TOOL_DEFINITIONS: ToolDefinition[] = [
  EDIT_FILE_TOOL,
  APPLY_DIFF_TOOL
];

/**
 * Get a tool definition by name
 */
export function getToolDefinition(name: string): ToolDefinition | undefined {
  return TOOL_DEFINITIONS.find(tool => tool.name === name);
}

/**
 * Validate parameters against a tool's schema
 */
export function validateToolParams(toolName: string, params: any): { valid: boolean; errors: string[] } {
  const tool = getToolDefinition(toolName);
  
  if (!tool) {
    return {
      valid: false,
      errors: [`Unknown tool: ${toolName}`]
    };
  }
  
  const errors: string[] = [];
  const schema = tool.inputSchema;
  
  // Check required parameters
  for (const required of schema.required) {
    if (!(required in params)) {
      errors.push(`Missing required parameter: ${required}`);
    }
  }
  
  // Basic type checking
  for (const [key, value] of Object.entries(params)) {
    if (!(key in schema.properties)) {
      errors.push(`Unknown parameter: ${key}`);
      continue;
    }
    
    const propSchema = schema.properties[key];
    const actualType = Array.isArray(value) ? 'array' : typeof value;
    
    if (propSchema.type !== actualType) {
      errors.push(`Parameter '${key}' should be ${propSchema.type}, got ${actualType}`);
    }
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}
